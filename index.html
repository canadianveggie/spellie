<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Spellie | Wordle for Kids</title>
    <meta name="description" content="A kid-friendly version of the popular Wordle game" />

    <meta property="og:url" content="https://spelliegame.com" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Spellie - A daily word game for young spellers" />
    <meta property="og:description" content="Wordle for kids. 3 daily puzzles for children of all ages." />
    <meta property="og:image" content="https://spelliegame.com/preview.png" />
    <meta name="twitter:image" content="https://spelliegame.com/preview.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png" />
    <link rel="manifest" href="site.webmanifest" />

    <script src="public/polyfill.js"></script>
    <script src="https://unpkg.com/alpinejs@3.10.5/dist/cdn.min.js" defer></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <link href="./public/main.css" rel="stylesheet" />
    <script src="public/amplitude.js"></script>
  </head>

  <body
    x-data="gameState()"
    x-init="initialLoad()"
    :class="`theme-${settings.theme} page-${page.replace('#', '')}`"
    @keyup.document="keyPressed"
    @hashchange.window="updatePage(location.hash)"
  >
    <header>
      <nav>
        <div>
          <a href="#about" class="nav-link" title="About">
            <i class="material-icons">info</i>
          </a>
          <a href="#archive" class="nav-link" title="Archive" @click="loadArchive">
            <i class="material-icons">calendar_month</i>
          </a>
        </div>
        <div class="title">
          <a x-bind:href="gameUrl"
            >Spellie<span x-cloak x-show="isArchiveGame" x-text="archiveDate" class="archive-title"></span
          ></a>
          <span x-cloak x-show="isAprilFools" title="April Fools!">üôÉ</span>
        </div>
        <div>
          <a href="#collection" class="nav-link" title="Collection">
            <span
              class="nav-notification"
              x-cloak
              x-show="sessionNewEmojis.length > 0"
              x-text="sessionNewEmojis.length"
            ></span>
            <i class="material-icons">collections</i>
          </a>
          <a href="#settings" class="nav-link" title="Settings">
            <i class="material-icons">settings</i>
          </a>
        </div>
      </nav>
      <div class="nav-tabs" x-cloak x-show="isGamePage">
        <button :class="{ 'active': difficulty === 'easy' }" @click="updateDifficulty('easy')">Easy</button>
        <button :class="{ 'active': difficulty === 'medium' }" @click="updateDifficulty('medium')">Medium</button>
        <button :class="{ 'active': difficulty === 'hard' }" @click="updateDifficulty('hard')">Hard</button>
      </div>
    </header>
    <main :class="`target-${target.length}`">
      <div class="about-content" x-show="page === '#about'" x-cloak>
        <div class="subhead">
          <h1>About</h1>
          <div>
            <a x-bind:href="gameUrl">
              <i class="material-icons">close</i>
            </a>
          </div>
        </div>
        <p>Spellie is a daily word puzzle game for young spellers.</p>
        <p>
          There are 3 daily puzzles of increasing difficulty. The easy puzzle uses short words within the Grade 2
          vocabulary. The hard mode is challenging, but uses words within the Grade 5 vocabulary.
        </p>

        <h2>How to play</h2>
        <p>You have six (6) tries to guess the daily word, using the feedback to narrow down the options.</p>
        <div class="example-word">
          <div class="guesses-word" :class="settings.case">
            <div class="guesses-tile match">
              <span>W</span>
            </div>
            <div class="guesses-tile miss">
              <span>O</span>
            </div>
            <div class="guesses-tile present">
              <span>R</span>
            </div>
            <div class="guesses-tile miss">
              <span>D</span>
            </div>
          </div>
        </div>
        <ul>
          <li>
            The letter
            <span :class="settings.case" class="heavy-letter">W</span>
            is in the word and in the right spot.
          </li>
          <li>
            The letter
            <span :class="settings.case" class="heavy-letter">R</span>
            is in the word but in the wrong spot.
          </li>
          <li>
            The letters
            <span :class="settings.case" class="heavy-letter">O</span> and
            <span :class="settings.case" class="heavy-letter">D</span>
            are not in the word in any spot.
          </li>
        </ul>

        <h2>Creators</h2>
        <ul>
          <li>Christopher Porter</li>
          <li>David Hirtle</li>
          <li>James Dodds</li>
          <li>
            Many other
            <a href="https://github.com/canadianveggie/spellie" target="_blank">contributors</a>
          </li>
        </ul>
        <div class="social-links">
          <a href="https://mastodon.social/@spellie" target="_blank"
            ><img src="public/mastodon.png" alt="Mastodon"
          /></a>
          <a href="https://twitter.com/SpellieGame" target="_blank"><img src="public/twitter.png" alt="Twitter" /></a>
          <a href="https://github.com/canadianveggie/spellie" target="_blank"
            ><img src="public/github.png" alt="GitHub"
          /></a>
        </div>
      </div>
      <div class="game-content" x-show="isGamePage">
        <div class="guesses-grid">
          <template x-for="(guess, guessIndex) in guesses" :key="`${gameId}-${guessIndex}`">
            <div class="guesses-row" :class="settings.case">
              <template x-for="(letter, letterIndex) in guess">
                <div
                  class="guesses-tile"
                  :class="[letter.state, isCursor(guessIndex, letterIndex) ? 'cursor' : '']"
                  @click="selectTile(guessIndex, letterIndex)"
                >
                  <span x-show="letter.letter" x-text="masked ? '' : letter.letter" x-transition:enter="pop"></span>
                </div>
              </template>
            </div>
          </template>
        </div>
        <div class="hint-area" x-show="hintsAvailable">
          <button
            class="hint-button"
            @click="showHint"
            x-show="hint.available"
            x-transition:enter.duration.500ms
            x-cloak
          >
            Need a hint? ü§î
          </button>
        </div>
        <div x-show="solved && endGame" x-cloak>
          <div x-transition.enter.duration.1000ms x-transition.leave.duration.0ms class="victory">
            <span class="emoji" x-text="victoryEmoji"></span> You win!
          </div>
        </div>
        <div x-cloak x-show="failed && endGame" x-transition:enter.duration.1000ms class="defeat">
          <span x-show="masked">Nice try!</span>
          <span x-cloak x-show="!masked">It was: <span x-text="target"></span></span>
        </div>
        <div x-cloak x-show="endGame" class="masked-game-buttons">
          <button @click="masked ? unmask : mask">
            <span x-text="masked ? 'Reveal' : 'Hide'"></span>
            <i class="material-icons" aria-hidden="true" x-text="masked ? 'visibility' : 'visibility_off'"></i>
          </button>
          <button @click="resetLevel">
            <span>Reset</span>
            <i class="material-icons" aria-hidden="true">replay</i>
          </button>
          <button @click="share" x-show="canShare">
            <span>Share</span>
            <i class="material-icons" aria-hidden="true">share</i>
          </button>
        </div>
        <div class="keyboard">
          <template x-if="!endGame">
            <template x-for="(keyboardRow, rowIndex) in keyboard" :key="`${gameId}-${rowIndex}`">
              <div class="keyboard-row">
                <template x-for="letter in keyboardRow" :key="`${gameId}-${letter.label}`">
                  <div
                    class="key"
                    :class="[settings.case, 'key-' + letter.type, letter.state, hint.shown && letter.label === hint.letter ? 'pulse' : '']"
                    @click="addLetter(letter)"
                    @keyup.enter.stop="addLetter(letter)"
                    role="button"
                    tabindex="0"
                  >
                    <template x-if="letter.type === 'back'">
                      <i class="material-icons">backspace</i>
                    </template>
                    <template x-if="letter.type !== 'back'">
                      <span x-text="letter.label"></span>
                    </template>
                  </div>
                </template>
              </div>
            </template>
          </template>
        </div>
        <div class="helpers">
          <script>
            function containsCharsFromArray(word, letterArray) {
              // console.log('containsCharsFromArray');
              // console.log(word);
              // console.log(letterArray);
              var countOfHits = 0;
              var hitsNeeded = word.length;
              for (let i = 0; i < word.length; i++) {
                const letter = word[i];
                if (letterArray.indexOf(letter)) {
                  // console.log(letter);
                  countOfHits++;
                  // console.log(hitsNeeded);
                  // console.log('counthits: ' + countOfHits);
                  // console.log('letter: ' + letter);
                }
              }
              if (hitsNeeded == countOfHits) {
                return true;
              }
              else {
                return false;
              }
            }

            function generateWords() {
              // Get what letters are correct or not.
              var keyboard = document.querySelectorAll( '.key-letter:not(.miss)' );
              var letters = [];
              for( var i = 0; i < keyboard.length; i++ ) {
                letters.push(keyboard[i]['outerText']);
              }

              // Get difficulty.
              var difficulty = getInitialDifficulty();
              var wordLengthToCheck = 4;
              switch (difficulty) {
                case 'easy':
                  wordLengthToCheck = 4;
                  break;
                case 'medium':
                  wordLengthToCheck = 5;
                  break;
                case 'hard':
                  wordLengthToCheck = 6;
                  break;
              }

              // Figure out what words are possible from the validWords dictionary set.
              var possibleWords = [];
              // console.log(validWords);
              for (var it = validWords.values(), val= null; val=it.next().value; ) {
                if (val.length == wordLengthToCheck) {
                  val = val.toLowerCase();
                  // console.log(val);
                  if (containsCharsFromArray(val, letters)) {
                    possibleWords.push(val);
                  }
                }
              }
              // console.log(possibleWords);

              // Look at the prior guesses to help limit the possible words.
              var guesses = document.querySelectorAll('.game-content .guesses-tile:not(.pending):not(.emoji-tile)' );

              // Need to leverage wordLengthToCheck to figure out how many letters across there are.
              // Then need to figure out if you have a hit in any of them.
              // Keep track of those.
              var correctLetters = [];
              for( var i = 0; i < wordLengthToCheck; i++ ) {
                correctLetters[i] = '';
              }
              for( var i = 0; i < guesses.length; i++ ) {
                var currentGuess = guesses[i];
                if (currentGuess.classList.contains('match')) {
                  var letterPosition = i % wordLengthToCheck;
                  correctLetters[letterPosition] = guesses[i]['outerText'].charAt(0);
                }
              }

              // console.log(correctLetters);
              // console.log(possibleWords);
              var newPossibleWords = [];
              var arrayLength = possibleWords.length;
              for (var i = 0; i < arrayLength; i++) {
                // console.log(possibleWords[i]);
                //Do something
                // possibleWords.push(val);
                // str.charAt(0);
                var allHits = true;

                // console.log(wordLengthToCheck);
                for( var j = 0; j < wordLengthToCheck; j++ ) {
                  // console.log(correctLetters[j].length);
                  var thisLetter = correctLetters[j];
                  // console.log(thisLetter);
                  // console.log(thisLetter.length);
                  if (thisLetter.length > 0) {
                    // console.log('compare these letters');
                    // console.log(correctLetters[j]);
                    // console.log(possibleWords[i].charAt(j));
                    // If a letter doesn't match,
                    // console.log('letter; ' + correctLetters[j]);
                    // console.log('possible word letter; ' + possibleWords[i].charAt(j));
                    if (correctLetters[j] !== possibleWords[i].charAt(j)) {
                      allHits = false;
                      // console.log('hit');
                    }
                  }

                }
                if (allHits) {
                  // console.log('in if');
                  // console.log(possibleWords[i]);
                  newPossibleWords.push(possibleWords[i]);
                }
              }
              // console.log(newPossibleWords);

              // Generate 5 items from possibleWords.
              var words = newPossibleWords.sort(() => Math.random() - Math.random()).slice(0, 5)
              // console.log(words);
              // Display 5 items.
              const ul = document.createElement("ul");
              ul.setAttribute("id", "word-suggestions");
              for (const item of words) {
                const li = document.createElement("li");
                li.textContent = item;
                ul.appendChild(li);
              }
              // Replace UL of #word-suggestions.
              const oldElement = document.getElementById("word-suggestions");
              oldElement.replaceWith(ul);

            }
          </script>
          <!-- Button to generate words -->
          <button id="clickMe" @click="generateWords">Generate Words</button>
          <h2>Word suggestions</h2>
          <ul id="word-suggestions"></ul>


        </div>
      </div>
      <div class="collection-content" x-show="page === '#collection'" x-cloak>
        <div class="subhead">
          <h1>Collection</h1>
          <div>
            <a x-bind:href="gameUrl" class="close-link">
              <i class="material-icons">close</i>
            </a>
          </div>
        </div>

        <p x-show="unlockedEmojis.length === 0">
          Your word guesses can unlock hidden emojis.<br />Maybe you'll find one next game.
        </p>
        <p x-show="unlockedEmojis.length === 1">
          You found your first emoji! Great job.<br />How many more can you find?
        </p>
        <p x-show="unlockedEmojis.length > 1 && lockedEmojis.length > 0">
          You've already found
          <strong x-text="unlockedEmojis.length"></strong> emojis. That's amazing!<br />Can you find any more?
        </p>
        <p x-show="lockedEmojis.length === 0">Congratulations! ü¶Ñ You've found every emoji! ü§©</p>
        <div class="collection-tiles">
          <div class="guesses-word" x-show="unlockedEmojis.length === 0" :class="settings.case">
            <div class="guesses-tile emoji-tile">
              <span>‚ùì</span>
            </div>
            <template x-for="letter in '????'">
              <div class="guesses-tile match">
                <span x-text="letter"></span>
              </div>
            </template>
          </div>
          <template x-for="(collectable, i) in unlockedEmojis">
            <div class="guesses-word" x-show="collectable.unlocked" :class="[settings.case]">
              <div class="guesses-tile emoji-tile">
                <img
                  :src="getEmojiImage(collectable.emoji)"
                  :onerror="`this.onerror=null;this.replaceWith('${collectable.emoji}')`"
                  class="emoji-image"
                  :class="collectable.new ? 'pulse' : ''"
                  width="32"
                  height="32"
                  :alt="collectable.word"
                />
              </div>
              <template x-for="letter in collectable.word">
                <div class="guesses-tile" :class="collectable.new ? 'present' : 'match'">
                  <span x-text="letter"></span>
                </div>
              </template>
            </div>
          </template>
        </div>
        <p x-show="unlockedEmojis.length > 1 && lockedEmojis.length > 0">
          Psst. There are over
          <span x-text="Math.floor(Object.keys(emojis).length / 100)  * 100"></span>
          emojis in total...
        </p>
        <div class="hint-area" x-show="unlockedEmojis.length >= 100 && lockedEmojis.length > 0" x-cloak>
          <button class="hint-button" @click="showEmojiHint">Need a hint? ü§î</button>
        </div>
      </div>
      <div class="archive-content" x-show="page === '#archive'" x-cloak>
        <div class="subhead">
          <h1>Archive</h1>
          <div>
            <a x-bind:href="gameUrl" class="close-link">
              <i class="material-icons">close</i>
            </a>
          </div>
        </div>

        <div class="archive-list">
          <template x-for="(archivePuzzle) in archivePuzzles" :key="archivePuzzle.puzzleId">
            <div class="archive-row">
              <div class="archive-date">
                <span x-text="formatArchiveDate(archivePuzzle.puzzleId)"></span>
              </div>
              <div class="archive-buttons">
                <button :class="archivePuzzle.easy" @click="updateDifficulty('easy', archivePuzzle.puzzleId)">
                  Easy
                </button>
                <button :class="archivePuzzle.medium" @click="updateDifficulty('medium', archivePuzzle.puzzleId)">
                  Medium
                </button>
                <button :class="archivePuzzle.hard" @click="updateDifficulty('hard', archivePuzzle.puzzleId)">
                  Hard
                </button>
              </div>
            </div>
          </template>
        </div>
      </div>
      <div class="settings-content" x-show="page === '#settings'" x-cloak>
        <div class="subhead">
          <h1>Settings</h1>
          <div>
            <a x-bind:href="gameUrl" class="close-link">
              <i class="material-icons">close</i>
            </a>
          </div>
        </div>
        <section>
          <h2>Keyboard layout</h2>
          <div>
            <input
              type="radio"
              id="keyboardLayout-atoz"
              value="atoz"
              x-model="settings.keyboardLayout"
              @change="updateSettings"
            />
            <label for="keyboardLayout-atoz">A to Z</label>
          </div>
          <div>
            <input
              type="radio"
              id="keyboardLayout-qwerty"
              value="qwerty"
              x-model="settings.keyboardLayout"
              @change="updateSettings"
            />
            <label for="keyboardLayout-qwerty">QWERTY</label>
          </div>
        </section>
        <section>
          <h2>Letters</h2>
          <div>
            <input
              type="radio"
              id="case-lowercase"
              value="lowercase"
              x-model="settings.case"
              @change="updateSettings"
            />
            <label for="case-lowercase">lowercase</label>
          </div>
          <div>
            <input
              type="radio"
              id="case-uppercase"
              value="uppercase"
              x-model="settings.case"
              @change="updateSettings"
            />
            <label for="case-uppercase">UPPERCASE</label>
          </div>
        </section>
        <section>
          <h2>Spell checker</h2>
          <div>
            <input
              type="radio"
              id="spellChecker-off"
              value="off"
              x-model="settings.spellChecker"
              @change="updateSettings"
            />
            <label for="spellChecker-off">Off</label>
          </div>
          <div>
            <input
              type="radio"
              id="spellChecker-on"
              value="on"
              x-model="settings.spellChecker"
              @change="updateSettings"
            />
            <label for="spellChecker-on">On</label>
          </div>
        </section>
        <section>
          <h2>Hints</h2>
          <div>
            <input type="radio" id="hints-off" value="off" x-model="settings.hints" @change="updateSettings" />
            <label for="hints-off">Off</label>
          </div>
          <div>
            <input type="radio" id="hints-on" value="on" x-model="settings.hints" @change="updateSettings" />
            <label for="hints-on">On</label>
          </div>
        </section>
        <section>
          <h2>Theme</h2>
          <div>
            <input type="radio" id="theme-blue" value="blue" x-model="settings.theme" @change="updateSettings" />
            <label for="theme-blue">Default</label>
          </div>
          <div>
            <input type="radio" id="theme-high" value="high" x-model="settings.theme" @change="updateSettings" />
            <label for="theme-high">High contrast</label>
          </div>
        </section>
        <section>
          <h2>Sharing theme</h2>
          <template x-for="entries in Object.entries(emojiMatchThemes)">
            <div class="sharing-theme-row">
              <input
                :id="'sharing-emojis-' + entries[0]"
                type="radio"
                :value="entries[0]"
                x-model="settings.sharingEmojis"
                @change="updateSettings"
              />
              <label
                :for="'sharing-emojis-' + entries[0]"
                dddx-text="entries[1].match + entries[1].present + entries[1].miss"
              >
                <img
                  :src="getEmojiImage(entries[1].match)"
                  class="emoji-image"
                  width="20"
                  height="20"
                  :onerror="`this.onerror=null;this.replaceWith('${entries[1].match}')`"
                  :alt="entries[1].match"
                />
                <img
                  :src="getEmojiImage(entries[1].present)"
                  class="emoji-image"
                  width="20"
                  height="20"
                  :onerror="`this.onerror=null;this.replaceWith('${entries[1].present}')`"
                  :alt="entries[1].present"
                />
                <img
                  :src="getEmojiImage(entries[1].miss)"
                  class="emoji-image"
                  width="20"
                  height="20"
                  :onerror="`this.onerror=null;this.replaceWith('${entries[1].miss}')`"
                  :alt="entries[1].miss"
                />
              </label>
            </div>
          </template>
        </section>
      </div>
      <div
        x-data="noticesHandler()"
        class="notice"
        @notice.window="notify($event.detail)"
        x-cloak
        x-show="notice && notice.visible"
        @click="remove(notice && notice.id)"
        @keyup.document.escape="remove(notice && notice.id)"
        x-html="message"
        x-transition:enter="fadein"
      ></div>
    </main>
  </body>

  <script src="public/puzzles.js"></script>
  <script src="public/wordHints.js"></script>
  <script src="public/hint.js"></script>
  <script src="public/emojis.js"></script>
  <script src="public/mobileCheck.js"></script>
  <script src="public/dictionary.js"></script>
  <script>
    /* global amplitude, combineKnowledge, compareTargetAndGuess, emojis, getDateForPuzzleId, getEmojiImage, getHint, getPuzzlesForId, getTodayPuzzleId, guessesAsEmojis, keysToKnowledge, onMobile, validWords */
    const identify = new amplitude.Identify().set("host", window.location.hostname);
    amplitude.getInstance().identify(identify);

    let todaysPuzzleId = getTodayPuzzleId();
    const maxGuesses = 6;
    initScalingFontSize();

    // Add emoji keys to valid words
    // So that ELSA and ROFL are accepted
    Object.keys(emojis).forEach((key) => validWords.add(key));

    function initialKeys() {
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
      const keyboard = letters.map((letter) => ({
        type: "letter",
        label: letter,
        state: "available",
      }));
      keyboard.push({
        type: "back",
        label: "",
        state: "unavailable",
      });
      keyboard.push({
        type: "enter",
        label: "guess",
        state: "unavailable",
      });
      return keyboard;
    }

    function emptyGuesses(wordLength, guessLength) {
      const guesses = [];
      for (let i = 0; i < guessLength; i++) {
        const guess = [];
        for (let j = 0; j < wordLength; j++) {
          guess.push({ letter: "", state: "pending" });
        }
        guesses.push(guess);
      }
      return guesses;
    }

    const DIFFICULTIES = ["easy", "medium", "hard"];

    function getInitialDifficulty() {
      const page = window.location.hash.replace("#", "");
      const [difficulty] = page.split("-", 2);

      if (DIFFICULTIES.includes(difficulty)) {
        return difficulty;
      }
      return "easy";
    }

    function getInitialPuzzleId() {
      const page = window.location.hash.replace("#", "");
      const [, page2] = page.split("-", 2);

      const pagePuzzleId = parseInt(page2, 10);
      if (!Number.isNaN(pagePuzzleId)) {
        return pagePuzzleId;
      }
      return todaysPuzzleId;
    }

    // eslint-disable-next-line no-unused-vars
    function gameState() {
      const DEFAULT_SETTINGS = {
        case: "lowercase", // lowercase, uppercase
        hints: "on", // on, off
        keyboardLayout: "qwerty", // atoz, qwerty
        sharingEmojis: "nature", // fruit, vegetable, nature, tree
        spellChecker: "on", // on, off
        theme: "blue", // blue, high
      };
      const DEFAULT_STATISTICS = {};
      DIFFICULTIES.forEach((difficulty) => {
        DEFAULT_STATISTICS[difficulty] = {
          success: 0,
          fail: 0,
          guesses: [0, 0, 0, 0, 0, 0, 0],
          solved: {},
        };
      });
      const DEFAULT_HINT = {
        available: false,
        shown: false,
        message: null,
        timer: null,
      };

      const HINT_DELAY = 10 * 1000;

      return {
        settings: {}, // placeholder until x-init
        page: window.location.hash,
        difficulty: getInitialDifficulty(),
        puzzleId: getInitialPuzzleId(),
        target: "",
        guesses: [],
        solved: false,
        failed: false,
        masked: false,
        endGame: false,
        repeatedGame: false,
        gameId: 0,
        hint: DEFAULT_HINT,
        currentGuessIndex: 0,
        cursor: 0,
        cursorMode: false,
        keys: initialKeys(),
        archivePuzzles: [],
        emojiCollection: [],
        newEmojis: [],
        hintKnowledge: {
          matches: [],
          presents: [],
          misses: [],
          availables: [],
        },
        updateTitle() {
          const titles = {
            "#easy": "Spellie | Easy",
            "#medium": "Spellie | Medium",
            "#hard": "Spellie | Hard",
            "#archive": "Spellie | Archive",
            "#collection": "Spellie | Emoji Collection",
            "#settings": "Spellie | Settings",
            "#about": "Spellie | About",
          };
          if (titles[this.page]) {
            document.title = titles[this.page];
          } else if (this.isArchiveGame()) {
            document.title = titles[`#${this.difficulty}`] + this.archiveDate;
          } else {
            document.title = "Spellie | Wordle for Kids";
          }
        },
        updatePage(page) {
          this.page = page;
          this.updateTitle();
        },
        addLetter(letterState) {
          if (this.solved || this.failed) {
            return;
          }
          if (letterState.type === "enter") {
            if (!this.isCurrentWordComplete()) {
              return;
            }
            if (this.isCurrentWordInvalid()) {
              this.showNotice("Check your spelling... ü§î");
              return;
            }
            this.currentGuess.forEach((letterGuess) => (letterGuess.state = "submitted"));
            this.resetHint();
            this.checkAnswer();
            if (!this.solved && !this.failed) {
              this.cursor = this.cursorReverse ? this.target.length - 1 : 0;
              this.prepareHint();
            } else if (this.solved) {
              // Move cursor off the page
              this.cursor = this.target.length;
            }
            this.updateControls();
            this.saveGameState();
            this.cursorMode = false;
          } else if (letterState.type === "back") {
            const deleteIndex = this.cursorMode ? this.cursor : this.cursorAdjust(-1);
            if (
              deleteIndex >= 0 &&
              deleteIndex < this.currentGuess.length &&
              this.currentGuess[deleteIndex].state !== "match" // keep freebie
            ) {
              this.currentGuess[deleteIndex].letter = "";
              if (this.cursorMode) {
                this.cursorMode = false;
              } else if (this.cursorReverse) {
                this.cursor = Math.min(this.target.length - 1, this.cursor + 1);
              } else {
                this.cursor = Math.max(0, this.cursor - 1);
              }
              this.updateControls();
            }
          } else if (letterState.type === "letter") {
            if (this.currentGuess && this.cursor >= 0 && this.cursor < this.currentGuess.length) {
              this.currentGuess[this.cursor].letter = letterState.label.toUpperCase();
              this.cursor = this.cursorAdjust(1);
              this.cursorMode = false;
              this.updateControls();
            }
          }
        },
        checkAnswer() {
          if (this.currentGuessIndex === 0) {
            amplitude.getInstance().logEvent("level_start", {
              level_name: this.level,
              difficulty: this.difficulty,
              archiveGame: this.isArchiveGame(),
              repeatedGame: this.repeatedGame,
            });
          }
          const result = compareTargetAndGuess(this.target, this.currentWord);
          result.forEach((letterResult, i) => {
            this.currentGuess[i].state = letterResult;
          });
          this.updateKeyboardForGuess(this.currentWord);
          this.checkEmojiGuess();
          this.solved = this.currentWord === this.target;
          this.currentGuessIndex += 1;
          if (this.solved) {
            this.levelEnd();
            return;
          }
          if (!this.solved && !this.failed && this.currentGuessIndex >= this.guesses.length) {
            this.failed = true;
            this.levelEnd();
          }
        },
        checkEmojiGuess() {
          const emoji = emojis[this.currentWord];
          const alreadyFound = this.unlockedEmojis.some((entry) => entry.word === this.currentWord);
          if (emoji && !alreadyFound) {
            if (this.lockedEmojis.length === 1) {
              this.showNotice(`You unlocked the last emoji #${emoji}# !`);
            } else {
              this.showNotice(`You unlocked #${emoji}# !`);
            }
            this.newEmojis.push(emoji);
            const collection = this.getFromLocalStorage("collection", {
              unlocked: {},
            });
            collection.unlocked[this.currentWord] = {
              date: new Date().toISOString(),
            };
            localStorage.setItem("collection", JSON.stringify(collection));
            const collectable = this.emojiCollection.find((c) => c.word === this.currentWord);
            collectable.unlocked = true;
            collectable.new = true;
          }
        },
        updateKeyboardForGuess(guess) {
          const result = compareTargetAndGuess(this.target, guess);
          result.forEach((letterResult, i) => {
            const label = guess[i];
            const key = this.keys.find((letter) => letter.label === label);
            // Don't overwrite match or present with miss
            if (!key || key.state === "match" || (key.state === "present" && letterResult === "miss")) {
              return;
            }
            key.state = letterResult;
          });
        },
        updateKeyboardForHints(hintKnowledge) {
          hintKnowledge.misses.forEach((missLetter) => {
            const key = this.keys.find((letter) => letter.label === missLetter);
            key.state = "miss";
          });
          hintKnowledge.presents.forEach((presentLetter) => {
            const key = this.keys.find((letter) => letter.label === presentLetter);
            if (key.state === "available") {
              key.state = "present";
            }
          });
        },
        updateKeyboard() {
          this.keys.forEach((key) => {
            if (key.type === "letter") {
              key.state = "available";
            }
          });
          this.guessWords.forEach((guessWord) => {
            this.updateKeyboardForGuess(guessWord);
          });
          this.updateKeyboardForHints(this.hintKnowledge);
          this.updateControls();
        },
        get keyboard() {
          const aToZ = ["ABCDEFGHI", "JKLMNOPQR", "STUVWXYZ"];
          const qwerty = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"];

          const layout = this.settings.keyboardLayout === "qwerty" ? qwerty : aToZ;
          const keyboard = [];
          layout.forEach((row) => {
            const rowKeys = row.split("").map((letter) => {
              return this.keys.find((key) => key.label === letter);
            });
            keyboard.push(rowKeys);
          });
          keyboard[2].push(this.keys.find((key) => key.type === "back"));
          keyboard[3] = [this.keys.find((key) => key.type === "enter")];
          return keyboard;
        },
        updateControls() {
          const backKey = this.keys.find((letter) => letter.type === "back");
          const enterKey = this.keys.find((letter) => letter.type === "enter");
          backKey.state = this.cursor > 0 ? "available" : "unavailable";
          if (this.cursorReverse) {
            backKey.state = this.cursor < this.target.length - 1 ? "available" : "unavailable";
          }
          enterKey.state =
            this.isCurrentWordComplete() && !this.isCurrentWordInvalid() ? "available pulse-small" : "unavailable";
        },
        keyPressed(e) {
          if (this.page === "#collection" && e.key === "?") {
            this.showEmojiHint();
          }

          if (!this.isGamePage()) return;
          if (e.key === "Tab") return;

          if (e.key === "Enter" || e.key === " ") {
            e.target.blur();
            this.addLetter({ type: "enter" });
          } else if (e.key === "Backspace") {
            e.target.blur();
            this.addLetter({ type: "back" });
          } else if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
            const delta = e.key === "ArrowLeft" ? -1 : 1;
            const nextCursorIndex = Math.min(this.target.length - 1, Math.max(0, this.cursor + delta));
            if (this.currentGuess[nextCursorIndex].state === "match") {
              return; // don't allow reaching a freebie letter
            }
            this.cursor = nextCursorIndex;
            this.cursorMode = true;
          } else if (/^[a-zA-Z]$/.test(e.key) && !e.altKey && !e.ctrlKey && !e.metaKey) {
            e.target.blur(); // user is no longer navigating by tab
            this.addLetter({ type: "letter", label: e.key });
          }
        },
        selectTile(guessIndex, letterIndex) {
          if (
            !this.solved &&
            guessIndex === this.currentGuessIndex &&
            this.currentGuess[letterIndex].state !== "match"
          ) {
            this.cursor = letterIndex;
            this.cursorMode = true;
          }
        },
        get currentGuess() {
          return this.guesses[this.currentGuessIndex];
        },
        guessToWord(guess) {
          return guess && guess.map((letterGuess) => letterGuess.letter || " ").join("");
        },
        get lastWord() {
          const guess = this.guesses[this.currentGuessIndex - 1];
          return guess ? this.guessToWord(guess) : "";
        },
        get currentWord() {
          return this.guessToWord(this.currentGuess);
        },
        get guessWords() {
          return this.guesses.slice(0, this.currentGuessIndex).map((guess) => this.guessToWord(guess));
        },
        get guessWordDictionary() {
          return this.guessWords.reduce((acc, guessWord, i) => {
            acc[`guess${i + 1}`] = guessWord;
            return acc;
          }, {});
        },
        get guessEmojis() {
          return this.guessWords.map((guessWord) => emojis[guessWord]);
        },
        get onLastGuess() {
          return this.currentGuessIndex === maxGuesses - 1;
        },
        isCurrentWordComplete() {
          return (
            this.currentWord && this.currentWord.length === this.target.length && this.currentWord.indexOf(" ") < 0
          );
        },
        isCurrentWordInvalid() {
          return (this.settings.spellChecker === "on" || this.onLastGuess) && !validWords.has(this.currentWord);
        },
        isCursor(guessIndex, letterIndex) {
          return guessIndex === this.currentGuessIndex && letterIndex === this.cursor;
        },
        cursorAdjust(delta) {
          if (this.cursorReverse) {
            return this.cursor - delta;
          } else {
            return this.cursor + delta;
          }
        },
        get victoryEmoji() {
          const victoryEmojis = this.isAprilFools()
            ? ["üëΩ", "ü¶∏‚Äç‚ôÄÔ∏è", "üòª", "ü•∏", "üç™", "ü•µ"]
            : ["üèÜ", "ü§©", "ü•≥", "üòÅ", "üôÇ", "üëç"];
          return victoryEmojis[this.currentGuessIndex - 1] || victoryEmojis[victoryEmojis.length - 1];
        },
        /** First letter provided free for 4-letter words */
        prepareFreebie() {
          const freebieIndex = this.cursorReverse ? this.target.length - 1 : 0;
          if (this.target.length <= 4 && this.guesses[0][freebieIndex].letter === "") {
            this.addLetter({
              type: "letter",
              label: this.target[freebieIndex],
            });
            this.guesses[0][freebieIndex].state = "match"; // set this already as signal to player
          }
        },
        get hintsAvailable() {
          return this.settings.hints === "on" && this.difficulty !== "hard";
        },
        prepareHint() {
          if (this.difficulty === "hard" || this.currentGuessIndex < 2 || this.solved || this.failed) {
            this.resetHint();
            return;
          }

          try {
            const hint = getHint(
              this.target,
              combineKnowledge(keysToKnowledge(this.keys), this.hintKnowledge),
              this.settings,
              this.currentGuessIndex,
              this.lastWord
            );
            if (hint) {
              this.hint = hint;
              this.hint.timer = setTimeout(() => {
                this.hint.available = true;
              }, HINT_DELAY);
            } else {
              this.resetHint();
            }
          } catch (e) {
            console.error("Unable to prepare a hint.", e);
          }
        },
        resetHint() {
          clearTimeout(this.hint.timer);
          this.hint = { ...DEFAULT_HINT };
        },
        showEmojiHint() {
          if (this.lockedEmojis.length === 0) {
            return;
          }

          const collection = this.getFromLocalStorage("collection", {
            unlocked: {},
            hint: {},
          });

          const hintDuration = 60 * 60 * 1000; // 1 hour between collection hints
          if (!collection.hint || !collection.hint.date || new Date() - new Date(collection.hint.date) > hintDuration) {
            const randomEmojiIndex = Math.floor(Math.random() * this.lockedEmojis.length);
            const randomLockedEmoji = this.lockedEmojis[randomEmojiIndex];
            collection.hint = {
              ...randomLockedEmoji,
              date: new Date().toISOString(),
            };
            localStorage.setItem("collection", JSON.stringify(collection));

            amplitude.getInstance().logEvent("show_emoji_hint", {
              emoji: collection.hint.emoji,
              word: collection.hint.word,
              emojiCount: this.unlockedEmojis.length,
            });
          }

          let blanks = Array(collection.hint.word.length).fill("_ ").join("");
          const foundEmoji = this.unlockedEmojis.some((entry) => entry.word === collection.hint.word);
          if (foundEmoji) {
            // If the emoji is since found, show the word in the hint
            blanks = collection.hint.word;
          }
          this.showNotice(`${blanks} = #${collection.hint.emoji}#`, "hint");
        },
        showHint() {
          if (!this.hint.shown) {
            amplitude.getInstance().logEvent("show_hint", {
              level_name: this.level,
              difficulty: this.difficulty,
              archiveGame: this.isArchiveGame(),
              repeatedGame: this.repeatedGame,
              guess: this.currentGuessIndex + 1,
              message: this.hint.message,
              letter: this.hint.letter,
            });
            this.hint.shown = true;
          }
          this.showNotice(this.hint.message, "hint");
          const newKnowledge = {
            presents: this.hint.letter ? [this.hint.letter] : [],
            misses: this.hint.misses || [],
          };
          this.hintKnowledge = combineKnowledge(this.hintKnowledge, newKnowledge);
          this.updateKeyboardForHints(this.hintKnowledge);
        },
        showNotice(text, type) {
          window.dispatchEvent(
            new CustomEvent("notice", {
              detail: { text, type },
            })
          );
        },
        initialLoad() {
          this.loadSettings();
          this.loadGameState();
          this.loadCollection();
          this.loadArchive();
          this.updateTitle();
        },
        formatGameStateVariable(difficulty, puzzleId) {
          return `game-state-${difficulty}-${puzzleId}`;
        },
        get gameStateVariable() {
          return this.formatGameStateVariable(this.difficulty, this.puzzleId);
        },
        getGameStateFromLocalStorage(difficulty, puzzleId) {
          const state = this.getFromLocalStorage(this.formatGameStateVariable(difficulty, puzzleId), undefined);
          if (state) {
            return state;
          }

          // Look for the old way we stored this
          // Note: can remove after a few days
          const oldState = this.getFromLocalStorage(`game-state-${difficulty}`, {});
          if (oldState.puzzleId === puzzleId) {
            return oldState;
          }
          return {};
        },
        loadGameState() {
          if (!this.isArchiveGame() && todaysPuzzleId !== getTodayPuzzleId()) {
            // Update today's puzzle for stale sessions
            todaysPuzzleId = getTodayPuzzleId();
            this.puzzleId = todaysPuzzleId;
          }

          try {
            const initialState = this.getGameStateFromLocalStorage(this.difficulty, this.puzzleId);
            // Create a unique id for each game state so that we redraw the grid and keyboard properly
            this.gameId += 1;
            this.level = initialState.level || `${this.difficulty}-${this.puzzleId}`;
            this.target = initialState.target || getPuzzlesForId(this.puzzleId)[this.difficulty];

            this.guesses = initialState.guesses || emptyGuesses(this.target.length, maxGuesses);
            this.solved = initialState.solved || false;
            this.failed = initialState.failed || false;
            this.repeatedGame = initialState.repeatedGame || false;
            this.masked = this.solved || this.failed;
            this.endGame = this.solved || this.failed;
            this.currentGuessIndex = initialState.currentGuessIndex || 0;
            this.cursorReverse = this.isAprilFools();
            this.cursor = initialState.cursor || (this.cursorReverse ? this.target.length - 1 : 0);
            this.cursorMode = initialState.cursorMode || false;
            this.newEmojis = initialState.newEmojis || [];
            this.hintKnowledge = initialState.hintKnowledge || {};
            // Ensure all the knowledge is present. We used to save it as an empty object
            this.hintKnowledge.matches = this.hintKnowledge.matches || [];
            this.hintKnowledge.presents = this.hintKnowledge.presents || [];
            this.hintKnowledge.misses = this.hintKnowledge.misses || [];
            this.hintKnowledge.availables = this.hintKnowledge.availables || [];
            this.updateKeyboard();
            this.resetHint();
            clearTimeout(this.endGameTimer);
            this.prepareHint();
            this.prepareFreebie();
          } catch (err) {
            console.error(err);
          }
        },
        saveGameState() {
          localStorage.setItem(this.gameStateVariable, JSON.stringify(this.toJson()));
        },
        loadSettings() {
          const dayOverwrites = this.isAprilFools() ? { sharingEmojis: "poop" } : {};
          this.settings = {
            ...DEFAULT_SETTINGS,
            ...this.getFromLocalStorage("settings", {}),
            ...dayOverwrites,
          };
          if (this.settings.sharingEmojis === "") {
            // Removing random default for now
            this.settings.sharingEmojis = DEFAULT_SETTINGS.sharingEmojis;
          }
        },
        saveSettings() {
          localStorage.setItem("settings", JSON.stringify(this.settings));
          this.loadGameState();
        },
        updateSettings() {
          this.saveSettings();
          this.showNotice("Settings updated");
        },
        isArchiveGame() {
          return this.puzzleId !== todaysPuzzleId;
        },
        get gameUrl() {
          let hash = `#${this.difficulty}`;
          if (this.isArchiveGame()) {
            hash += `-${this.puzzleId}`;
          }
          return hash;
        },
        isGamePage() {
          if (this.page === "") {
            return true;
          }
          const [pageDifficulty] = this.page.split("-");
          return DIFFICULTIES.map((d) => `#${d}`).includes(pageDifficulty);
        },
        updateDifficulty(difficulty, puzzleId) {
          this.difficulty = difficulty;
          if (puzzleId !== undefined) {
            this.puzzleId = puzzleId;
          }

          window.location.hash = this.gameUrl;
          this.loadGameState();
        },
        loadArchive() {
          const statistics = this.getFromLocalStorage("statistics", DEFAULT_STATISTICS);
          this.archivePuzzles = [];
          for (let i = 0; i <= todaysPuzzleId; i++) {
            this.archivePuzzles[i] = {
              puzzleId: i,
            };
            DIFFICULTIES.forEach((difficulty) => {
              const archivePuzzleGameState = this.getGameStateFromLocalStorage(difficulty, i);
              let state = "unsolved";
              if (archivePuzzleGameState.solved) {
                state = "solved";
              } else if (statistics && statistics.solved && statistics.solved[i] && statistics.solved[i][difficulty]) {
                state = "solved";
              } else if (archivePuzzleGameState.guesses && archivePuzzleGameState.guesses.length > 0) {
                state = "in-progress";
              }
              this.archivePuzzles[i][difficulty] = state;
            }, this);
          }
          this.archivePuzzles.reverse();
        },
        loadCollection() {
          const collection = this.getFromLocalStorage("collection", {
            unlocked: {},
          });
          this.emojiCollection = Object.entries(emojis)
            .sort(
              (a, b) => a[0] - b[0] // Sort alphabetical
            )
            .map(([word, emoji]) => ({
              word,
              emoji,
              unlocked: Object.keys(collection.unlocked).indexOf(word) >= 0,
            }));
          const identifyEmojis = new amplitude.Identify().set("emojiCount", this.unlockedEmojis.length);
          amplitude.getInstance().identify(identifyEmojis);
        },
        levelEnd() {
          amplitude.getInstance().logEvent("level_end", {
            level_name: this.level,
            difficulty: this.difficulty,
            guesses: this.solved ? this.currentGuessIndex : null,
            success: this.solved,
            archiveGame: this.isArchiveGame(),
            repeatedGame: this.repeatedGame,
            guessWords: this.guessWords,
            newEmojis: this.newEmojis,
            newEmojiCount: this.newEmojis.length,
            emojiCount: this.unlockedEmojis.length,
            ...this.guessWordDictionary,
          });
          this.endGameTimer = setTimeout(() => {
            this.endGame = true;
            if (!this.solved) {
              this.masked = true;
            } else {
              // Wait until after the victoryEmoji animation to mask
              this.endGameTimer = setTimeout(() => {
                this.masked = true;
              }, 6000);
            }
          }, this.target.length * 250 + 1000); // 1 second after last letter shows up
          const statistics = this.getFromLocalStorage("statistics", DEFAULT_STATISTICS);

          if (this.solved) {
            statistics[this.difficulty].success += 1;
            statistics[this.difficulty].guesses[this.currentGuessIndex] += 1;
            statistics.solved = statistics.solved || {};
            statistics.solved[this.puzzleId] = statistics.solved[this.puzzleId] || {};
            statistics.solved[this.puzzleId][this.difficulty] = true;
          } else {
            statistics[this.difficulty].fail += 1;
          }
          localStorage.setItem("statistics", JSON.stringify(statistics));
        },
        get lockedEmojis() {
          return this.emojiCollection.filter((e) => !e.unlocked);
        },
        get unlockedEmojis() {
          return this.emojiCollection.filter((e) => e.unlocked);
        },
        get sessionNewEmojis() {
          return this.unlockedEmojis.filter((e) => e.new);
        },
        resetLevel() {
          localStorage.setItem(this.gameStateVariable, JSON.stringify({ repeatedGame: true, puzzleId: this.puzzleId }));
          amplitude.getInstance().logEvent("level_reset", {
            level_name: this.level,
            difficulty: this.difficulty,
            guesses: this.solved ? this.currentGuessIndex : null,
            success: this.solved,
            archiveGame: this.isArchiveGame(),
          });
          this.loadGameState();
        },
        mask() {
          this.masked = true;
        },
        unmask() {
          this.masked = false;
        },
        toJson() {
          return {
            target: this.target,
            level: this.level,
            puzzleId: this.puzzleId,
            guesses: this.guesses,
            solved: this.solved,
            failed: this.failed,
            repeatedGame: this.repeatedGame,
            currentGuessIndex: this.currentGuessIndex,
            cursor: this.cursor,
            cursorMode: this.cursorMode,
            newEmojis: this.newEmojis,
            hintKnowledge: this.hintKnowledge,
          };
        },
        get canShare() {
          return !!navigator && (!!navigator.share || !!navigator.clipboard);
        },
        share() {
          const title = "Spellie";
          let text;
          let shareType;
          if ((this.solved || this.failed) && this.isGamePage()) {
            // Spellie #10 (medium)
            // üï∏Ô∏èüï∏Ô∏èüï∏Ô∏èüï∏Ô∏èüï∏Ô∏è
            // üï∏Ô∏èüï∏Ô∏èüåªüçÄüï∏Ô∏è
            // üçÄüçÄüï∏Ô∏èüçÄüï∏Ô∏è
            // üçÄüçÄüçÄüçÄüçÄ
            text = `Spellie #${this.puzzleId} (${this.difficulty})\n${guessesAsEmojis(
              this.guesses,
              this.settings.sharingEmojis
            )}`;
            shareType = "puzzle";
          } else if (this.page === "#collection" && this.unlockedEmojis.length === 1) {
            // I collected my first emoji in Spellie! üë©‚Äçü¶±
            text = `I collected my first emoji in Spellie! ${this.unlockedEmojis[0].emoji}`;
            shareType = "emojis";
          } else if (this.page === "#collection" && this.unlockedEmojis.length > 1) {
            // I've collected 10 emojis in Spellie:
            // üêàüê©5Ô∏è‚É£4Ô∏è‚É£üëßüå≥üñåÔ∏è‚ôüÔ∏èüßó‚Äç‚ôÄÔ∏èüë©‚Äçü¶±
            text = `I've collected ${this.unlockedEmojis.length} emojis in Spellie:\n${this.unlockedEmojis
              .map((e) => e.emoji)
              .join("")}`;
            shareType = "emojis";
          } else {
            // Spellie
            // ‚ì¶‚ìû‚ì°‚ìì
            // üï∏Ô∏èüåªüçÄüï∏Ô∏è
            // ü§îü§îü§îü§î
            // ‚ìó‚ìî‚ì°‚ìûü¶∏
            const wordsMatch = [[{ state: "miss" }, { state: "present" }, { state: "match" }, { state: "miss" }]];
            const wordsEmojis = guessesAsEmojis(wordsMatch, this.settings.sharingEmojis);
            text = `Spellie\n‚ì¶‚ìû‚ì°‚ìì\n${wordsEmojis}\nü§îü§îü§îü§î\n‚ìó‚ìî‚ì°‚ìûü¶∏`;
            shareType = "basic";
          }

          const shareData = {
            title,
            text,
          };
          if (!!navigator.canShare && navigator.canShare(shareData) && onMobile()) {
            navigator.share(shareData);
          } else if (!!navigator.clipboard) {
            navigator.clipboard.writeText(shareData.text);
            this.showNotice("Copied to clipboard");
          }
          amplitude.getInstance().logEvent("clicked_share", {
            page: this.page,
            text,
            share_type: shareType,
            archiveGame: this.isArchiveGame(),
          });
        },
        getFromLocalStorage(key, defaultValue) {
          const value = localStorage.getItem(key);
          if (value) {
            return JSON.parse(value);
          }
          return defaultValue;
        },
        formatArchiveDate(puzzleId) {
          if (puzzleId === todaysPuzzleId) {
            return "Today";
          }
          return getDateForPuzzleId(puzzleId).toLocaleDateString("en-CA", { dateStyle: "medium" });
        },
        get archiveDate() {
          if (this.isArchiveGame()) {
            return (
              " " + getDateForPuzzleId(this.puzzleId).toLocaleDateString("en-CA", { month: "short", day: "numeric" })
            );
          }
          return "";
        },
        isAprilFools() {
          const puzzleDate = getDateForPuzzleId(this.puzzleId);
          return puzzleDate.getMonth() === 4 - 1 && puzzleDate.getDate() === 1;
        },
      };
    }

    function emojiReplace(text) {
      const stripped = text.replace(/(<([^>]+)>)/gi, "");
      // extract emoji between # characters
      // (actually detecting with regex has too many edge cases)
      const emojiMatch = stripped.match(/#(?<emoji>\S+)#/i);
      if (!emojiMatch) {
        return stripped;
      }
      const emojiImage = `<img src="${getEmojiImage(emojiMatch.groups.emoji)}" class="emoji-image" width="20" alt="${
        emojiMatch.groups.emoji
      }" />`;
      return stripped.replace(/#/g, "").replace(emojiMatch.groups.emoji, emojiImage);
    }

    // eslint-disable-next-line no-unused-vars
    function noticesHandler() {
      return {
        notice: null,
        type: null,
        notify(notice) {
          const visibleNotice = {
            ...notice,
            id: Date.now(),
            visible: true,
          };
          this.notice = visibleNotice;
          const timeShown = (notice.type === "hint" ? 10 : 5) * 1000;
          setTimeout(() => {
            this.remove(visibleNotice.id);
          }, timeShown);
        },
        remove(id) {
          if (this.notice && this.notice.id === id) {
            this.notice.visible = false;
          }
        },
        message() {
          if (!this.notice) return;

          if (this.notice.type === "hint") {
            return `<strong>Hint ü§î</strong><br>${emojiReplace(this.notice.text)}`;
          }

          return emojiReplace(this.notice.text);
        },
      };
    }

    function initScalingFontSize() {
      if ("ResizeObserver" in window === false) {
        // Old browser without a ResizeObserver, leave font size as defaults
        return;
      }

      const MAX_FONT_SIZE = 48;
      const grid = document.querySelector(".guesses-grid");

      /** Set grid font, which in turn impacts all guess tiles */
      function setGridFontSize(container) {
        if (!container.offsetWidth) return;

        let tileWidth;
        const sampleTile = container.querySelector(".guesses-tile");
        if (sampleTile && sampleTile.offsetWidth) {
          // found a tile, so base it on the tile dimensions
          tileWidth = sampleTile.offsetWidth;
        } else if (container.offsetHeight < container.offsetWidth) {
          // no tile (probably not yet rendered), so estimate it based on container
          tileWidth = container.offsetHeight / 6;
        } else {
          tileWidth = container.offsetWidth / 6;
        }

        const fontSize = 0.7 * tileWidth;
        grid.style.fontSize = `${Math.min(MAX_FONT_SIZE, fontSize)}px`;
      }

      const resizeObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          if (entry.target) {
            setGridFontSize(entry.target);
          }
        }
      });

      resizeObserver.observe(grid);
    }

    window.onerror = function onError(message, url, lineNo, columnNo, error) {
      try {
        if (url && url.includes("extension://")) {
          // Ignore problems with extensions
          return false;
        }
        amplitude.getInstance().logEvent("error_encountered", {
          message,
          url: window.location.href,
          source: `${url}:${lineNo}:${columnNo}`,
          error: JSON.stringify(error),
        });
      } catch (err) {
        // If we're having problems talking to amplitude
        // Don't throw another error in here
        console.error("Error encountered.", err);
      }

      return false;
    };
  </script>
</html>
