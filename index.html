<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Wordle Junior</title>
    <meta
      name="description"
      content="A kid-friendly version of the popular Wordle game"
    />

    <meta
      property="og:url"
      content="https://canadianveggie.github.io/wordle-junior/"
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:title"
      content="Wordle Junior - A daily word game for kids"
    />
    <meta
      property="og:description"
      content="Tricking kids into learning to spell since 2022"
    />
    <!-- <meta
      property="og:image"
      content="TODO.png"
    /> -->
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png" />
    <link rel="manifest" href="site.webmanifest" />

    <script src="//unpkg.com/alpinejs" defer></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Andika+New+Basic:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
    <link href="./public/main.css" rel="stylesheet" />
    <script src="public/amplitude.js"></script>
  </head>

  <body>
    <main
      x-data="gameState()"
      x-init="initialLoad()"
      @keyup.document="keyPressed"
      @hashchange.window="page = location.hash"
    >
      <header>
        <div class="nav">
          <a href="#" class="nav-link" x-show="page !== ''">
            <i class="material-icons">arrow_back</i>
          </a>
        </div>
        <div class="title">Wordle Junior</div>
        <div class="nav">
          <a href="#collection" class="nav-link">
            <i class="material-icons">collections</i>
          </a>
          <a href="#settings" class="nav-link">
            <i class="material-icons">settings</i>
          </a>
        </div>
      </header>
      <div class="game-content" x-show="page === ''">
        <div class="guesses">
          <template x-for="(guess, guessIndex) in guesses">
            <div class="guesses-word">
              <template x-for="(letter, letterIndex) in guess">
                <div
                  class="guesses-tile"
                  :class="[letter.state, isCursor(guessIndex, letterIndex) ? 'cursor' : '']"
                  @click="selectTile(guessIndex, letterIndex)"
                >
                  <span
                    x-show="letter.letter"
                    x-text="letter.letter"
                    x-transition:enter="pop"
                  ></span>
                </div>
              </template>
            </div>
          </template>
          <div class="hint-area">
            <button
              class="hint-button"
              @click="showHint"
              x-show="hint.available"
              x-transition:enter.duration.500ms
              x-cloak
            >
              Need a hint?
            </button>
            <div
              class="hint"
              x-show="hint.message"
              @click="resetHint"
              x-transition:enter.duration.1000ms
              x-transition:leave.duration.500ms
            >
              <span x-text="hint.message"></span>
            </div>
          </div>
        </div>
        <div class="keyboard">
          <div
            x-show="solved"
            x-cloak
            x-transition.duration.1000ms
            class="victory"
          >
            <span class="emoji" x-text="victoryEmoji"></span> You win!
          </div>
          <div
            x-cloak
            x-show="failed"
            x-transition.duration.1000ms
            class="defeat"
          >
            Nice try!
            <p x-text="target"></p>
          </div>
          <template x-if="!solved && !failed">
            <template x-for="letter in keyboard">
              <div
                class="key"
                x-text="letter.label"
                :class="['key-' + letter.type, letter.state, letter.label === hint.letter ? 'glow' : '']"
                @click="addLetter(letter)"
              ></div>
            </template>
          </template>
        </div>
      </div>
      <div class="help-content" x-show="page === '#help'">
        <h1>Help</h1>
      </div>
      <div class="collection-content" x-show="page === '#collection'">
        <h1>Collection</h1>
        <div class="collection-tiles">
          <template x-for="(collectable, i) in emojiCollection">
            <div class="guesses-word" x-show="collectable.unlocked">
              <span x-text="collectable.emoji"></span>
              <template x-for="letter in collectable.word">
                <div class="guesses-tile match">
                  <span x-text="letter"></span>
                </div>
              </template>
            </div>
          </template>
        </div>
      </div>
      <div class="settings-content" x-show="page === '#settings'">
        <h1>Settings</h1>
        <div>
          <h2>Difficulty</h2>
          <label>
            <input
              type="radio"
              id="easy"
              value="easy"
              x-model="settings.difficulty"
              @change="updateSettings()"
            />
            Easy</label
          >
          <label>
            <input
              type="radio"
              id="medium"
              value="medium"
              x-model="settings.difficulty"
              @change="updateSettings()"
            />Medium</label
          >
          <label>
            <input
              type="radio"
              id="hard"
              value="hard"
              x-model="settings.difficulty"
              @change="updateSettings()"
            />
            Hard
          </label>
        </div>
        <div>
          <h2>Keyboard Layout</h2>
          <label
            ><input
              type="radio"
              id="atoz"
              value="atoz"
              x-model="settings.keyboardLayout"
              @change="updateSettings()"
            />A to Z</label
          >
          <label
            ><input
              type="radio"
              id="qwerty"
              value="qwerty"
              x-model="settings.keyboardLayout"
              @change="updateSettings()"
            />QWERTY</label
          >
        </div>
      </div>
    </main>
  </body>

  <script src="public/puzzles.js"></script>
  <script src="public/hint.js"></script>
  <script src="public/emojis.js"></script>
  <script>
    const puzzleId = getTodayPuzzleId();
    const maxGuesses = 6;

    function initialKeyboard(keyboardLayout) {
      const a_z = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
      const qwerty = "QWERTYUIOPASDFGHIJKLZXCVBNM".split("");

      const keys = keyboardLayout === "qwerty" ? qwerty : a_z;

      const keyboard = keys.map((letter) => ({
        type: "letter",
        label: letter,
        state: "available",
      }));
      keyboard.push({
        type: "back",
        label: "‚Üê",
        state: "unavailable",
      });
      keyboard.push({
        type: "enter",
        label: "guess",
        state: "unavailable",
      });
      return keyboard;
    }

    function emptyGuesses(wordLength, guessLength) {
      const guesses = [];
      for (let i = 0; i < guessLength; i++) {
        const guess = [];
        for (let j = 0; j < wordLength; j++) {
          guess.push({ letter: "", state: "pending" });
        }
        guesses.push(guess);
      }
      return guesses;
    }

    function gameState() {
      const DEFAULT_SETTINGS = {
        difficulty: "easy", // easy, medium, hard
        keyboardLayout: "atoz", // atoz, qwerty
      };
      const HINT_DELAY = 10 * 1000;

      return {
        page: location.hash,
        puzzleId,
        target: "",
        emoji: "üî†",
        guesses: [],
        solved: false,
        failed: false,
        hint: {
          available: false,
          message: null,
          timer: null,
        },
        currentGuessIndex: 0,
        cursor: 0,
        cursorMode: false,
        keyboard: [],
        emojiCollection: [],
        addLetter(letterState) {
          if (this.solved || this.failed) {
            return;
          }
          if (letterState.type === "enter") {
            if (!this.isCurrentWordComplete()) {
              return;
            }
            this.currentGuess.forEach(
              (letterGuess) => (letterGuess.state = "submitted")
            );
            this.resetHint();
            this.checkAnswer();
            if (!this.solved && !this.failed) {
              this.currentGuessIndex += 1;
              this.cursor = 0;
              this.prepareHint();
            }
            this.updateControls();
            this.saveGameState();
          } else if (letterState.type === "back") {
            const deleteIndex = this.cursorMode ? this.cursor : this.cursor - 1;
            if (deleteIndex >= 0) {
              this.currentGuess[deleteIndex].letter = "";
              this.cursor = Math.max(0, this.cursor - 1);
              this.updateControls();
            }
          } else if (letterState.type === "letter") {
            if (this.cursor < this.currentGuess?.length) {
              this.currentGuess[this.cursor].letter =
                letterState.label.toUpperCase();
              this.cursor += 1;
              this.updateControls();
            }
          }
        },
        checkAnswer() {
          const result = compareTargetAndGuess(this.target, this.currentWord);
          result.forEach((letterResult, i) => {
            this.currentGuess[i].state = letterResult;
          });
          this.updateKeyboardForGuess(this.currentWord);
          this.emoji = emojis[this.currentWord] || this.emoji;
          this.addToCollection(this.currentWord);
          this.solved = this.currentWord === this.target;
          if (this.solved) {
            amplitude.getInstance().logEvent("level_end", {
              level_name: this.level,
              guesses: this.currentGuessIndex + 1,
              success: true,
            });
            return;
          }
          if (
            !this.solved &&
            this.currentGuessIndex >= this.guesses.length - 1
          ) {
            this.failed = true;
            amplitude.getInstance().logEvent("level_end", {
              level_name: this.level,
              success: false,
            });
          }
        },
        updateKeyboardForGuess(guess) {
          const result = compareTargetAndGuess(this.target, guess);
          result.forEach((letterResult, i) => {
            const label = guess[i];
            const key = this.keyboard.find((letter) => letter.label === label);
            // Don't overwrite match or present with miss
            if (
              !key ||
              key.state === "match" ||
              (key.state === "present" && letterResult === "miss")
            ) {
              return;
            }
            key.state = letterResult;
          });
        },
        updateKeyboard() {
          for (const guess of this.guesses.slice(0, this.currentGuessIndex)) {
            this.updateKeyboardForGuess(this.guessToWord(guess));
          }
        },
        updateControls() {
          const backKey = this.keyboard.find(
            (letter) => letter.type === "back"
          );
          const enterKey = this.keyboard.find(
            (letter) => letter.type === "enter"
          );
          backKey.state = this.cursor > 0 ? "available" : "unavailable";
          enterKey.state = this.isCurrentWordComplete()
            ? "available pulse"
            : "unavailable";
        },
        keyPressed(e) {
          if (e.key === "Enter") {
            this.addLetter({ type: "enter" });
            this.cursorMode = false;
          } else if (e.key === "Backspace") {
            this.addLetter({ type: "back" });
          } else if (e.key === "ArrowLeft") {
            this.cursor = Math.max(0, this.cursor - 1);
            this.cursorMode = true;
          } else if (e.key === "ArrowRight") {
            this.cursor = Math.min(this.target.length - 1, this.cursor + 1);
            this.cursorMode = true;
          } else if (e.key === "?") {
            this.showHint();
          } else if (e.key === "+") {
            this.updateSettings({ difficulty: "medium" });
          } else if (e.key === "-") {
            this.updateSettings({ difficulty: "easy" });
          } else if (e.key === "=") {
            this.updateSettings({ difficulty: "hard" });
          } else if (
            /^[a-zA-Z]$/.test(e.key) &&
            !e.altKey &&
            !e.ctrlKey &&
            !e.metaKey
          ) {
            this.addLetter({ type: "letter", label: e.key });
            this.cursorMode = false;
          }
        },
        selectTile(guessIndex, letterIndex) {
          if (!this.solved && guessIndex === this.currentGuessIndex) {
            this.cursor = letterIndex;
            this.cursorMode = true;
          }
        },
        get currentGuess() {
          return this.guesses[this.currentGuessIndex];
        },
        guessToWord(guess) {
          return guess
            ?.map((letterGuess) => letterGuess.letter || " ")
            .join("");
        },
        get currentWord() {
          return this.guessToWord(this.currentGuess);
        },
        isCurrentWordComplete() {
          return (
            this.currentWord?.length === this.target.length &&
            this.currentWord.indexOf(" ") < 0
          );
        },
        isCursor(guessIndex, letterIndex) {
          return (
            guessIndex === this.currentGuessIndex && letterIndex === this.cursor
          );
        },
        get victoryEmoji() {
          const victoryEmojis = ["üèÜ", "ü§©", "ü•≥", "üòÅ", "üôÇ", "üëç"];
          return victoryEmojis[this.currentGuessIndex ?? 5];
        },
        prepareHint() {
          if (
            this.settings.difficulty !== "easy" ||
            this.currentGuessIndex === 0 ||
            this.solved ||
            this.failed
          ) {
            return;
          }
          this.hint.timer = setTimeout(() => {
            if (!this.hint.message) {
              this.hint.available = true;
            }
          }, HINT_DELAY);
        },
        resetHint() {
          clearTimeout(this.hint.timer);
          this.hint.available = false;
          this.hint.letter = null;
          this.hint.message = null;
        },
        showHint() {
          const hint = getHint(
            this.target,
            this.keyboard.filter((key) => key.type === "letter")
          );
          amplitude.getInstance().logEvent("show_hint", {
            level_name: this.level,
            message: hint.text,
            letter: hint.letter,
          });
          this.hint.message = hint.text;
          this.hint.letter = hint.letter;
          this.hint.available = false;
        },
        initialLoad() {
          this.loadSettings();
          this.loadGameState();
          this.loadCollection();
        },
        loadGameState() {
          try {
            this.target = getTodayPuzzles()[this.settings.difficulty];
            this.level = `${this.settings.difficulty}-${this.puzzleId}`;

            let initialState = JSON.parse(
              localStorage.getItem("game-state") || "{}"
            );
            if (initialState.target !== this.target) {
              initialState = {};
              amplitude.getInstance().logEvent("level_start", {
                level_name: this.level,
              });
            }
            this.guesses =
              initialState.guesses ||
              emptyGuesses(this.target.length, maxGuesses);
            this.solved = initialState.solved || false;
            this.failed = initialState.failed || false;
            this.currentGuessIndex = initialState.currentGuessIndex || 0;
            this.cursor = initialState.cursor || 0;
            this.cursorMode = initialState.cursorMode || false;
            this.keyboard = initialKeyboard(this.settings.keyboardLayout);
            this.updateKeyboard();
            this.prepareHint();
          } catch (err) {
            console.error(err);
          }
        },
        saveGameState() {
          localStorage.setItem("game-state", JSON.stringify(this.toJson()));
        },
        loadSettings() {
          this.settings = {
            ...DEFAULT_SETTINGS,
            ...JSON.parse(localStorage.getItem("settings") || "{}"),
          };
        },
        updateSettings(delta) {
          this.settings = { ...this.settings, ...delta };
          localStorage.setItem("settings", JSON.stringify(this.settings));
          this.loadGameState();
        },
        loadCollection() {
          const collection = JSON.parse(
            localStorage.getItem("collection") || '{"unlocked": {}}'
          );
          this.emojiCollection = Object.entries(emojis).map(([word, emoji]) => {
            return {
              word,
              emoji,
              unlocked: Object.keys(collection.unlocked).indexOf(word) >= 0,
            };
          });
        },
        addToCollection(newWord) {
          if (emojis[newWord]) {
            const collection = JSON.parse(
              localStorage.getItem("collection") || '{"unlocked": {}}'
            );
            collection.unlocked[newWord] = { date: new Date().toISOString() };
            localStorage.setItem("collection", JSON.stringify(collection));
            const collectable = this.emojiCollection.find(
              (collectable) => collectable.word === newWord
            );
            collectable.unlocked = true;
          }
        },
        toJson() {
          return {
            target: this.target,
            guesses: this.guesses,
            solved: this.solved,
            failed: this.failed,
            currentGuessIndex: this.currentGuessIndex,
            cursor: this.cursor,
            cursorMode: this.cursorMode,
          };
        },
      };
    }
  </script>
</html>
